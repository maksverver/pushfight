// Each input file contains two Elias-Fano encoded streams with the losses and
// wins generated by solve2 (note that the losses are expected to lie within
// the range of the input chunk, while the wins can occur everywhere).
//
// This tool deduplicates the wins and groups them by chunk, producing an
// output file with 7429*2 Elias-Fano encoded streams:
//
//  - new losses in chunk 0
//  - new wins in chunk 0
//  - new losses in chunk 1
//  - new wins in chunk 1
//  - etc.

#include "bytes.h"
#include "chunks.h"
#include "efcodec.h"
#include "macros.h"

#include <algorithm>
#include <cassert>
#include <iostream>
#include <optional>
#include <vector>

namespace {

std::vector<std::vector<int>> chunk_losses(num_chunks);
std::vector<std::vector<int>> chunk_wins(num_chunks);

}  // namespace

int main(int argc, char *argv[]) {
  if (argc < 2) {
    std::cout << "Usage: combine-two <chunk-rN-two.bin...>\n\n";
    std::cout << "Writes combined output to stdout!\n";
    return 0;
  }

  FOR(i, 1, argc) {
    const char *filename = argv[i];
    bytes_t bytes = ReadFromFile(filename);
    byte_span_t byte_span = bytes;
    REP(p, 2) {
      const char *what = p == 0 ? "losses" : "wins";
      std::vector<std::vector<int>> &dst = p == 0 ? chunk_losses : chunk_wins;
      std::optional<std::vector<int64_t>> ints = DecodeEF(&byte_span);
      if (!ints) {
        std::cerr << "Failed to decode " << what << " in file: " << filename << std::endl;
        return 1;
      }
      for (int64_t i : *ints) {
        int chunk = i / chunk_size;
        if (chunk < 0 || chunk >= num_chunks) {
          std::cerr << "Invalid permutation index " << i << " in file: " << filename << std::endl;
          return 1;
        }
        dst[chunk].push_back(i % chunk_size);
      }
    }
  }
  REP(chunk, num_chunks) {
    REP(p, 2) {
      std::vector<int> &src = (p == 0 ? chunk_losses : chunk_wins)[chunk];
      if (p == 0) {
        assert(std::is_sorted(src.begin(), src.end()));
        assert(std::unique(src.begin(), src.end()) == src.end());
      } else {
        std::sort(src.begin(), src.end());
        src.erase(std::unique(src.begin(), src.end()), src.end());
      }
      std::vector<int64_t> ints;
      ints.reserve(src.size());
      for (int i : src) {
        assert(i >= 0 && i < chunk_size);
        ints.push_back(int64_t{chunk} * int64_t{chunk_size} + int64_t{i});
      }
      bytes_t bytes = EncodeEF(ints);
      if (!std::cout.write(reinterpret_cast<const char*>(bytes.data()), bytes.size())) {
        std::cerr << "write() failed!" << std::endl;
        return 1;
      }
    }
  }
}
